<h1 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23)Rusts%20Module%20System%20Explained"></sup><a class="header-link" href="#id-%5B%5D(%23)Rusts%20Module%20System%20Explained"></a><p><a class="header-link" href="#id-%5B%5D(%23)Rusts%20Module%20System%20Explained"></a><a href="#"></a>Rusts Module System Explained</p></h1><h1 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">生锈模块系统解释</h1>
<p class="cyxy-trs-source cyxy-trs-source-ted">Table of Contents</p><p class="cyxy-trs-source cyxy-trs-target">目录</p>
<ul>
<li><a href="#why-do-modules-exist" class="cyxy-trs-source">Why do modules exist?<font class="cyxy-trs-target"> 模块为什么存在？</font></a></li>
<li><a href="#the-module-tree" class="cyxy-trs-source">The module tree<font class="cyxy-trs-target"> 模块树</font></a><ul>
<li><a href="#submodules" class="cyxy-trs-source">Submodules<font class="cyxy-trs-target"> 子模组</font></a></li>
<li><a href="#an-example" class="cyxy-trs-source">An example<font class="cyxy-trs-target"> 一个例子</font></a></li></ul></li>
<li><a href="#items-and-paths" class="cyxy-trs-source">Items and paths<font class="cyxy-trs-target"> 项目和路径</font></a></li>
<li><a href="#visibility" class="cyxy-trs-source">Visibility<font class="cyxy-trs-target"> 能见度</font></a><ul>
<li><a href="#encapsulation" class="cyxy-trs-source">Encapsulation<font class="cyxy-trs-target"> 封装</font></a></li>
<li><a href="#fine-grained-visibility" class="cyxy-trs-source">Fine-grained visibility<font class="cyxy-trs-target"> 细粒度的可见性</font></a></li>
<li><a href="#visibilities-overview" class="cyxy-trs-source">Visibilities overview<font class="cyxy-trs-target"> 可视性概述</font></a></li></ul></li>
<li><a href="#exports" class="cyxy-trs-source">Exports<font class="cyxy-trs-target"> 出口</font></a></li>
<li><a href="#common-pitfalls" class="cyxy-trs-source">Common pitfalls<font class="cyxy-trs-target"> 常见的陷阱</font></a></li>
<li><a href="#special-cases" class="cyxy-trs-source">Special cases<font class="cyxy-trs-target"> 特殊情况</font></a><ul>
<li><a href="#enum-variants-and-fields" class="cyxy-trs-source">Enum variants and fields<font class="cyxy-trs-target"> 变体和字段</font></a></li>
<li><a href="#macros" class="cyxy-trs-source">Macros<font class="cyxy-trs-target"> 宏</font></a></li></ul></li>
<li><a href="#why-are-modules-declared-explicitly" class="cyxy-trs-source">Why are modules declared explicitly?<font class="cyxy-trs-target"> 为什么要显式声明模块？</font></a></li>
<li><a href="#fin" class="cyxy-trs-source">Fin<font class="cyxy-trs-target"> 芬</font></a></li>
</ul>
<p class="cyxy-trs-source cyxy-trs-source-ted">The Rust programming language can be confusing for beginners, and the module system is one part that causes frustration particularly often. There are <wdautohl-customtag style="font-weight:bold;color:blue;font-size:inherit;display:inline;" id="wdautohl_id_2" class="wdautohl_cXVpdGUgYSBmZXc_">quite a few</wdautohl-customtag> blog posts out there trying to explain the module system in a simple way, but I often have the feeling that they over-simplify things. So here’s my take—​a more detailed explanation of the module system.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">Rust 编程语言对于初学者来说可能是混乱的，而且模块系统是特别经常引起挫折的一部分。有相当多的博客文章试图用一种简单的方式来解释模块系统，但是我经常感觉他们把事情过于简单化了。下面是我对这个模块系统的一个更详细的解释。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">This post assumes that you can write at least a “hello world” Rust program. It’s a rather long read, so get comfortable, maybe with a cup of tea, hot chocolate, or whatever your heart desires 😊</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">这篇文章假设你至少可以编写一个“ hello world”Rust 程序。这是一个相当长的阅读，所以舒适，也许一杯茶，热巧克力，或任何你心中想要的</p>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23why-do-modules-exist)Why%20do%20modules%20exist%3F"></sup><a class="header-link" href="#id-%5B%5D(%23why-do-modules-exist)Why%20do%20modules%20exist%3F"></a><p><a class="header-link" href="#id-%5B%5D(%23why-do-modules-exist)Why%20do%20modules%20exist%3F"></a><a href="#why-do-modules-exist"></a>Why do modules exist?</p></h2><h2 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">模块为什么存在？</h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">Modules give your code <em>structure</em>: Dividing your code into modules is like dividing your house into several rooms: Each room has a different purpose, and rooms can be locked for privacy.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">模块赋予你的代码结构: 将你的代码划分为模块就像将你的房子划分为几个房间: 每个房间都有不同的用途，而且为了保护隐私，房间可以上锁。</p>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23the-module-tree)The%20module%20tree"></sup><a class="header-link" href="#id-%5B%5D(%23the-module-tree)The%20module%20tree"></a><p><a class="header-link" href="#id-%5B%5D(%23the-module-tree)The%20module%20tree"></a><a href="#the-module-tree"></a>The module tree</p></h2><h2 class="cyxy-trs-source cyxy-trs-target">模块树</h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">Modules are structured in a <em>hierarchy</em>, the module tree, which is similar to the file tree of the source files. There are two kinds of modules: <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_3" class="wdautohl_aW5saW5l">Inline</wdautohl-customtag> modules and “normal” modules:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">模块以层次结构(即模块树)结构化，这与源文件的文件树类似。有两种模块: 内联模块和“普通”模块:</p>
<pre><small></small><div></div><code class="hljs language-gams"><span class="hljs-built_in">mod</span> inline {
    <span class="hljs-comment">// content of the module</span>
}

<span class="hljs-built_in">mod</span> <span class="hljs-built_in">normal</span>;
<span class="hljs-comment">// the content is in another file</span>
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">These are <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_5" class="wdautohl_ZnVuY3Rpb25hbGx5">functionally</wdautohl-customtag> equivalent. If the content of an <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_6" class="wdautohl_aW5saW5l">inline</wdautohl-customtag> module is very long, move it to another file, to keep the code neat and manageable.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">这些在功能上是等价的。如果内联模块的内容很长，那么将其移动到另一个文件中，以保持代码的整洁和可管理性。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">When the module is not <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_7" class="wdautohl_aW5saW5l">inline</wdautohl-customtag>, Rust looks for the content of the module in another file, either <code>_module_name_.rs</code> or <code>_module_name_/mod.rs</code>. It might seem odd that we have to declare modules explicitly (unlike in Python, where modules are <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_8" class="wdautohl_aW5mZXI_">inferred</wdautohl-customtag> from the file system). However, there are good reasons for this, as we’ll see later.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">当模块不是内联的时候，Rust 会在另一个文件中查找模块的内容，可以是 _ module _ name _。模块名称/模块名称。我们必须显式声明模块(不像 Python 中的模块是从文件系统推断出来的) ，这看起来可能有点奇怪。然而，正如我们将在后面看到的，这样做是有充分的理由的。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Like every tree, the module tree has a <em>root</em>. This is the file <code>lib.rs</code> in case of a library crate, or the file <code>main.rs</code> in case of a binary crate <sup class="footnote">[<a href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">像每一棵树一样，模块树也有一个根。如果是库板条箱，则使用文件 lib.rs; 如果是二进制板条箱[1] ，则使用文件 main.rs。</p>
<h3 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23submodules)Submodules"></sup><a class="header-link" href="#id-%5B%5D(%23submodules)Submodules"></a><p><a class="header-link" href="#id-%5B%5D(%23submodules)Submodules"></a><a href="#submodules"></a>Submodules</p></h3><h3 class="cyxy-trs-source cyxy-trs-target">子模组</h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Unfortunately, Rust is not the most consistent language when it comes to modules: There are two different ways to structure a module tree, and they can be mixed within the same crate.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">不幸的是，Rust 对于模块来说并不是最一致的语言: 有两种不同的方式来构造模块树，它们可以混合在同一个框架中。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Say we have a library crate with a module <code>parent</code>, which contains a sub-module <code>child</code>:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">假设我们有一个带有父模块的库框架，其中包含一个子模块子模块:</p>
<pre><small></small><div></div><code class="hljs language-markdown">└─ library root
   └─ parent
<span class="hljs-code">      └─ child
</span></code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">The crate root is in a <code>lib.rs</code> file in the <code>src</code> directory. However, the <code>parent</code> module can be either in a <code>parent.rs</code> file next to <code>lib.rs</code>, or in a <code>mod.rs</code> file in a <code>parent</code> directory:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">板条箱根目录位于 src 目录中的 lib.rs 文件中。但是，父模块可以位于 lib.rs 旁边的 parent.rs 文件中，也可以位于父目录中的 mod.rs 文件中:</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">File tree A</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">文件树 a</p>
<pre><small></small><div></div><code class="hljs language-stylus">├─ Cargo<span class="hljs-selector-class">.toml</span>
└─ <span class="hljs-attribute">src</span>/
   ├─ lib<span class="hljs-selector-class">.rs</span>
   ├─ parent<span class="hljs-selector-class">.rs</span>  <span class="hljs-comment">// parent module</span>
   └─ parent/
      └─ child<span class="hljs-selector-class">.rs</span>
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">File tree B</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">档案树 b</p>
<pre><small></small><div></div><code class="hljs language-stylus">├─ Cargo<span class="hljs-selector-class">.toml</span>
└─ <span class="hljs-attribute">src</span>/
   ├─ lib<span class="hljs-selector-class">.rs</span>
   └─ parent/
      ├─ mod<span class="hljs-selector-class">.rs</span>  <span class="hljs-comment">// parent module</span>
      └─ child<span class="hljs-selector-class">.rs</span>
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">It doesn’t really matter which way you go, just do what you prefer. I use the first way (“File tree A”), since it’s easier to add sub-modules. For example, if you want to add a submodule to <code>child</code>, you just need to create a folder and a new file, and add a <code>mod</code> declaration:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">你走哪条路并不重要，只要做你喜欢的就行了。我使用第一种方法(“文件树 a”) ，因为添加子模块更容易。例如，如果你想给 child 添加一个子模块，你只需要创建一个文件夹和一个新文件，然后添加一个 mod 声明:</p>
<pre><small></small><div></div><code class="hljs language-stylus"> ├─ Cargo<span class="hljs-selector-class">.toml</span>
 └─ <span class="hljs-attribute">src</span>/
    ├─ lib<span class="hljs-selector-class">.rs</span>
    ├─ parent<span class="hljs-selector-class">.rs</span>
    └─ parent/
       ├─ child<span class="hljs-selector-class">.rs</span>
      └─ child/
          └─ grand_child<span class="hljs-selector-class">.rs</span>
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">The path of a module can also be specified explicitly with the [<code>&lt;a target="_blank" href="https://doc.rust-lang.org/reference/items/modules.html#the-path-attribute"&gt;path]</code> attribute, but this is rarely used in practice.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">模块的路径也可以通过[ &lt; a target = " _ blank" href = " https://doc.rust-lang. org/reference/items/modules # The-path-attribute" &gt; path ]属性明确指定，但这在实践中很少使用。</p>
<h3 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23an-example)An%20example"></sup><a class="header-link" href="#id-%5B%5D(%23an-example)An%20example"></a><p><a class="header-link" href="#id-%5B%5D(%23an-example)An%20example"></a><a href="#an-example"></a>An example</p></h3><h3 class="cyxy-trs-source cyxy-trs-target">一个例子</h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Hopefully this will make more sense once you see an example. Here’s the module structure of a library crate:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">希望一旦你看到一个例子，这将会更有意义，下面是一个图书馆箱的模块结构:</p>
<pre><small></small><div></div><code class="hljs language-stylus">├─ Cargo<span class="hljs-selector-class">.toml</span>
└─ <span class="hljs-attribute">src</span>/
   ├─ lib<span class="hljs-selector-class">.rs</span>
   ├─ foo<span class="hljs-selector-class">.rs</span>
   ├─ bar<span class="hljs-selector-class">.rs</span>
   └─ bar/
      └─ baz<span class="hljs-selector-class">.rs</span>
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">lib.rs</p><p class="cyxy-trs-source cyxy-trs-target">莉比</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-comment">// root module</span>

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> foo;
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> bar;
</code></pre>
<p class="cyxy-trs-source">bar.rs</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> baz;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> baz::*;
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::foo::Answer;
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">foo.rs</p><p class="cyxy-trs-source cyxy-trs-target">好吧</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-keyword">mod</span> answer {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Answer</span>(<span class="hljs-keyword">pub</span> <span class="hljs-type">i32</span>);
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> answer::Answer;
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">baz.rs</p><p class="cyxy-trs-source cyxy-trs-target">巴兹</p>
<pre><small></small><div></div><code class="hljs language-scss">use super::Answer;

pub fn <span class="hljs-built_in">answer</span>() -&gt; Answer {
    <span class="hljs-built_in">Answer</span>(<span class="hljs-number">42</span>)
}
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">No worries if you don’t understand everything here! All the concepts that are used here will be explained. You can look at this example later and see if you understand everything. For now, do you know what the module tree is?</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">如果你不了解这里的一切，也不用担心！这里所使用的所有概念都将得到解释。您可以稍后查看这个示例，看看是否理解了所有内容。现在，您知道模块树是什么吗？</p>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23items-and-paths)Items%20and%20paths"></sup><a class="header-link" href="#id-%5B%5D(%23items-and-paths)Items%20and%20paths"></a><p><a class="header-link" href="#id-%5B%5D(%23items-and-paths)Items%20and%20paths"></a><a href="#items-and-paths"></a>Items and paths</p></h2><h2 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">项目和路径</h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">A module contains <em>items</em>. Items are</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">模块包含项</p>
<ul>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Functions</p><p class="cyxy-trs-source cyxy-trs-target">功能</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Types (structs, enums, unions, type <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_9" class="wdautohl_YWxpYXM_">aliases</wdautohl-customtag>)</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">类型(结构、枚举、联合、类型别名)</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Traits</p><p class="cyxy-trs-source cyxy-trs-target">特征</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Impl blocks</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">Impl 块</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Macros</p><p class="cyxy-trs-source cyxy-trs-target">宏</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Constants and statics</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">常数和静力学</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_10" class="wdautohl_ZXh0ZXJu">Extern</wdautohl-customtag> blocks</p><p class="cyxy-trs-source cyxy-trs-target">外部区块</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_11" class="wdautohl_ZXh0ZXJu">Extern</wdautohl-customtag> crates</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">外面的板条箱</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Imports</p><p class="cyxy-trs-source cyxy-trs-target">进口</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Modules</p><p class="cyxy-trs-source cyxy-trs-target">单元</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Associated items (not important right now)</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">相关项目(现在不重要)</p></li>
</ul>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can refer to items by their <em>path</em>. For example, the path <code>foo::bar::Baz</code> refers to the <code>Baz</code> item within the <code>bar</code> item within the <code>foo</code> item. Paths are usually relative: To use <code>foo::bar::Baz</code>, the <code>foo</code> item must be available in the current scope; absolute paths (starting at the root module) are <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_12" class="wdautohl_cHJlZml4">prefixed</wdautohl-customtag> with <code>crate::</code>. A <code>super::</code> path segment changes to the parent module (similar to <code>../</code> in the file system).</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">您可以根据项目的路径引用它们。例如，路径 foo: : bar: Baz 引用 foo 项中 bar 项中的 Baz 项。路径通常是相对的: 要使用 foo: : bar: : Baz，foo 项目必须在当前作用域中可用; 绝对路径(从根模块开始)以 crate: : 作为前缀。路径段更改为父模块(类似于。./在文件系统中)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>Imports</em> are used to <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_13" class="wdautohl_c2hvcnRlbg__">shorten</wdautohl-customtag> paths. Instead of having to write <code>foo::bar::Baz</code> every time, we can write <code>use foo::bar::Baz;</code> once. This brings the item into scope, so we can refer to it with the much shorter path <code>Baz</code>.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">导入用于缩短路径。不必每次都写 foo: : bar: Baz，我们可以使用 foo: : bar: Baz; 一次。这使得这个项目进入了范围，因此我们可以使用更短的路径 Baz 来引用它。</p>
<table>

<tbody>

<tr>

<td class="content"><span class="cyxy-trs-source cyxy-trs-source-ted">Changes to paths in the 2018 edition

Prior to the 2018 edition, absolute paths started with just `::` instead of `crate::`. In the 2018 edition, this syntax is still available, but it’s not recommended and can only be used for external crates.

In the 2015 edition, imports were always absolute, even when they weren’t <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_14" class="wdautohl_cHJlZml4">prefixed</wdautohl-customtag> with `::`. This was fixed in the 2018 edition for more consistency.

The 2018 edition also changed how external crates are used: In the 2015 edition, to use an external crate, an `extern crate` declaration was needed. This is no longer required in most cases: We can just put <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_15" class="wdautohl_ZGVwZW5kZW5jeQ__">dependencies</wdautohl-customtag> in our `Cargo.toml`, and use them right away.

</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">2018年版的路径变化在2018年版之前，绝对路径以‘ :’而不是‘ crate: :’开始。在2018年版本中，这种语法仍然可用，但是不推荐，只能用于外部箱子。在2015年的版本中，进口总是绝对的，即使前面没有加上‘ : :’。为了更加一致，2018年版本对此进行了修改。2018年版也改变了外部板条箱的使用方式: 在2015年版中，为了使用外部板条箱，需要一个外部板条箱声明。这在大多数情况下不再需要: 我们可以将依赖项放在 Cargo.toml 中，并立即使用它们。</span></td>

</tr>

</tbody>

</table>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23visibility)Visibility"></sup><a class="header-link" href="#id-%5B%5D(%23visibility)Visibility"></a><p><a class="header-link" href="#id-%5B%5D(%23visibility)Visibility"></a><a href="#visibility"></a>Visibility</p></h2><h2 class="cyxy-trs-source cyxy-trs-target">能见度</h2>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>Visibility</em>, or <em>privacy</em>, is the concept of making parts of a module <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_16" class="wdautohl_aW5hY2Nlc3NpYmxl">inaccessible</wdautohl-customtag> from other modules. Things that are only accessible in the same module are called <em>private</em>, and things that are accessible everywhere are called <em>public</em>.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">可见性，或者说隐私性，就是使模块的某些部分从其他模块中无法访问的概念。只有在同一个模块中才能访问的内容称为私有内容，而处处可访问的内容称为公有内容。</p>
<table>

<tbody>

<tr>

<td class="content"><span class="cyxy-trs-source cyxy-trs-source-ted">

This concept exists in many programming languages. However, in most object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_17" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> languages, the privacy boundary is the _class_, whereas in Rust, the modules are privacy boundaries.

</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">这个概念存在于许多编程语言中。然而，在大多数面向对象语言中，隐私边界是 _ class _，而在 Rust 中，模块是隐私边界。</span></td>

</tr>

</tbody>

</table>
<p class="cyxy-trs-source cyxy-trs-source-ted">In Rust, most things are private by default. To make something public, the <code>pub</code> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_18" class="wdautohl_a2V5d29yZA__">keyword</wdautohl-customtag> is written before it. This makes the item accessible everywhere:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">在 Rust 中，大多数东西默认是私人的。为了使某事公开，在它之前写上 pub 关键字。这使得这个项目无处不在:</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">lib.rs</p><p class="cyxy-trs-source cyxy-trs-target">莉比</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-keyword">mod</span> foo {  (<span class="hljs-number">1</span>)
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> bar {
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baz</span>;
    }
    <span class="hljs-comment">// use bar::Baz;  (2)</span>
}

<span class="hljs-keyword">use</span> foo::bar;  (<span class="hljs-number">3</span>)
</code></pre>
<table>

<tbody>

<tr>

<td class="cyxy-trs-source">**1**<font class="cyxy-trs-target" contenteditable="true"> * * * * *</font></td>

<td><span class="cyxy-trs-source cyxy-trs-source-ted">This declares a private module, so it can only be used within this root module. It can’t be accessed from another crate.</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">这声明了一个私有模块，因此它只能在这个根模块中使用。不能从另一个箱子进入。</span></td>

</tr>

<tr>

<td class="cyxy-trs-source">**2**<font class="cyxy-trs-target" contenteditable="true"> * * 2 * *</font></td>

<td><span class="cyxy-trs-source cyxy-trs-source-ted">If we uncommented this, it would fail to compile. `Baz` is private, therefore it can only be used within the `bar` module.</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">如果我们取消注释，它将无法编译。‘ Baz’是私有的，因此只能在‘ bar’模块中使用。</span></td>

</tr>

<tr>

<td class="cyxy-trs-source">**3**<font class="cyxy-trs-target" contenteditable="true"> * 3 * * *</font></td>

<td><span class="cyxy-trs-source cyxy-trs-source-ted">The module `bar` can be used here, because it is declared as public. This is somewhat counter-intuitive, since the `foo` module is private. But when a module is private, it can still be accessed within its direct parent module, since a module is just like any other item.</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">模块‘ bar’可以在这里使用，因为它被声明为公共的。这有点违反直觉，因为‘ foo’模块是私有的。但是，当模块是私有的时候，它仍然可以在它的直接父模块中访问，因为模块就像其他任何项目一样。</span></td>

</tr>

</tbody>

</table>
<h3 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23encapsulation)%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_19%22%20class%3D%22wdautohl_ZW5jYXBzdWxhdGlvbg__%22%3EEncapsulation%3C%2Fwdautohl-customtag%3E"></sup><a class="header-link" href="#id-%5B%5D(%23encapsulation)%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_19%22%20class%3D%22wdautohl_ZW5jYXBzdWxhdGlvbg__%22%3EEncapsulation%3C%2Fwdautohl-customtag%3E"></a><p><a class="header-link" href="#id-%5B%5D(%23encapsulation)%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_19%22%20class%3D%22wdautohl_ZW5jYXBzdWxhdGlvbg__%22%3EEncapsulation%3C%2Fwdautohl-customtag%3E"></a><a href="#encapsulation"></a><wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_19" class="wdautohl_ZW5jYXBzdWxhdGlvbg__">Encapsulation</wdautohl-customtag></p></h3><h3 class="cyxy-trs-source cyxy-trs-target">封装</h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">When designing an API, there are often <em>invariants</em> that need to be preserved. An <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_20" class="wdautohl_aW52YXJpYW50">invariant</wdautohl-customtag> is a property that never changes. For example, a struct might contain a value that is supposed to always be within the interval [0; 360):</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">在设计 API 时，通常需要保留不变量。不变式是一个永远不变的属性。例如，一个结构体可能包含一个值，该值应该总是在间隔[0; 360)内:</p>
<pre><small></small><div></div><code class="hljs language-reasonml">pub <span class="hljs-keyword">struct</span> <span class="hljs-constructor">Angle(<span class="hljs-params">pub</span> <span class="hljs-params">f32</span>)</span>;
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">Let’s write a <code>new</code> function that validates this <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_21" class="wdautohl_aW52YXJpYW50">invariant</wdautohl-customtag>, and a getter for the value:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">让我们编写一个新的函数来验证这个不变量，并为这个值编写一个 getter:</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Angle</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">f32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-title function_ invoke__">Angle</span>(value.<span class="hljs-title function_ invoke__">rem_euclid</span>(<span class="hljs-number">360.0</span>)) (<span class="hljs-number">1</span>)
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> {
        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>
    }
}
</code></pre>
<table>

<tbody>

<tr>

<td class="cyxy-trs-source">**1**<font class="cyxy-trs-target" contenteditable="true"> * * * * *</font></td>

<td><span class="cyxy-trs-source cyxy-trs-source-ted">[`rem_euclid`](https://doc.rust-lang.org/std/primitive.f32.html#method.rem_euclid) calculates the least nonnegative remainder of `self (mod rhs)`.</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">[’rem’euclid’]( https://doc.rust-lang.org/std/primitive.f32.html#method.rem_euclid )计算‘ self (mod rhs)’的最小非负余数。</span></td>

</tr>

</tbody>

</table>
<p class="cyxy-trs-source cyxy-trs-source-ted">By ensuring that the angle is always in [0; 360), we can implement operations such as equality (where 0° == 360°) very easily. But wait! Since the field is public, a user of the API can create an <code>Angle</code> object without calling the <code>new</code> function, or modify it without checking the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_22" class="wdautohl_aW52YXJpYW50">invariant</wdautohl-customtag>.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">通过确保角度始终在[0; 360]中，我们可以非常容易地实现等式(其中0 ° = 360 °)等操作。但是等等！因为字段是公共的，API 的用户可以创建一个 Angle 对象而不需要调用新函数，或者修改它而不需要检查不变量。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">By making the field private, the struct’s implementation details are hidden. This is called <em>encapsulation</em>: Within this module, we still have to take special care that the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_23" class="wdautohl_aW52YXJpYW50">invariant</wdautohl-customtag> is preserved, but if the code is correct, the public API is impossible to use incorrectly.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">通过将字段设置为私有，该结构的实现细节将被隐藏。这被称为封装: 在这个模块中，我们仍然需要特别注意保留不变式，但是如果代码是正确的，那么公共 API 就不可能被错误地使用。</p>
<h3 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23fine-grained-visibility)Fine-grained%20visibility"></sup><a class="header-link" href="#id-%5B%5D(%23fine-grained-visibility)Fine-grained%20visibility"></a><p><a class="header-link" href="#id-%5B%5D(%23fine-grained-visibility)Fine-grained%20visibility"></a><a href="#fine-grained-visibility"></a>Fine-grained visibility</p></h3><h3 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">细粒度的可见性</h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Items can be private or public. However, there are also visibilities in-between: Most notably, an item can be declared as <code>pub(crate)</code>. This means that it is visible <em>within the current crate</em>, but not outside. With <code>pub(super)</code>, an item is visible within the parent module. With <code>pub(in _path_)</code>, visibility can also be limited to any other module as well:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">项目可以是私人的，也可以是公共的。然而，在两者之间也有可见性: 最值得注意的是，一个项目可以声明为 pub (板条箱)。这意味着它在当前板条箱内是可见的，但在外部是不可见的。使用 pub (超级) ，在父模块中可以看到一个条目。使用 pub (in _ path _) ，可见性也可以限制到任何其他模块:</p>
<pre><small></small><div></div><code class="hljs language-scss"><span class="hljs-built_in">pub</span>(crate) mod foo {
    <span class="hljs-built_in">pub</span>(super) fn <span class="hljs-built_in">bar</span>() {}
    <span class="hljs-built_in">pub</span>(in crate::foo) struct Baz;
}
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">When something is visible in one module, it is also visible in all its child modules. It still needs to be imported (or referred to with its path) though:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">当一个模块中的某些内容可见时，它在其所有子模块中也可见。尽管如此，它仍然需要被导入(或者用它的路径来指代) :</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;
<span class="hljs-comment">// Foo is visible in this module</span>

<span class="hljs-keyword">mod</span> inner {
    <span class="hljs-keyword">use</span> super::Foo;
    <span class="hljs-comment">// Foo is also visible here!</span>
}
</code></pre>
<h3 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23visibilities-overview)Visibilities%20overview"></sup><a class="header-link" href="#id-%5B%5D(%23visibilities-overview)Visibilities%20overview"></a><p><a class="header-link" href="#id-%5B%5D(%23visibilities-overview)Visibilities%20overview"></a><a href="#visibilities-overview"></a>Visibilities overview</p></h3><h3 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">可视性概述</h3>
<table class="tableblock frame-all grid-all fit-content fancy"><colgroup><col> <col></colgroup> 

<tbody>

<tr>

<td class="tableblock halign-left valign-top cyxy-trs-source">

`pub`

<font class="cyxy-trs-target"> ”酒吧”</font></td>

<td class="tableblock halign-left valign-top cyxy-trs-source">

The item is visible everywhere

<font class="cyxy-trs-target" contenteditable="true"> 这件物品随处可见</font></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top cyxy-trs-source">

`pub(crate)`

<font class="cyxy-trs-target" contenteditable="true"> 酒吧(板条箱)</font></td>

<td class="tableblock halign-left valign-top"><span class="cyxy-trs-source cyxy-trs-source-ted">

The item is visible in the current crate

</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">该项在当前板条箱中可见</span></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top cyxy-trs-source">

`pub(super)`

<font class="cyxy-trs-target" contenteditable="true"> ‘ pub (super)’</font></td>

<td class="tableblock halign-left valign-top"><span class="cyxy-trs-source cyxy-trs-source-ted">

The item is visible in the parent module

</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">该项在父模块中可见</span></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top cyxy-trs-source">

`pub(in&nbsp;some::path)`

<font class="cyxy-trs-target" contenteditable="true"> ‘ pub (in some: : path)’</font></td>

<td class="tableblock halign-left valign-top"><span class="cyxy-trs-source cyxy-trs-source-ted">

The item is visible in the specified path. The path must refer to an <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_24" class="wdautohl_YW5jZXN0b3I_">ancestor</wdautohl-customtag> module of the item.

</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">该项在指定路径中可见。该路径必须引用该项的祖先模块。</span></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top cyxy-trs-source">

`pub(self)`

<font class="cyxy-trs-target" contenteditable="true"> ‘ pub (self)’</font></td>

<td class="tableblock halign-left valign-top"><span class="cyxy-trs-source cyxy-trs-source-ted">

The item is private, i.e. visible only in the same module. This is equivalent to <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_25" class="wdautohl_b21pdA__">omitting</wdautohl-customtag> the visibility entirely.

</span><span class="cyxy-trs-source cyxy-trs-target" contenteditable="true">该项是私有的，即只在同一个模块中可见。这等同于完全忽略可见性。</span></td>

</tr>

</tbody>

</table>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23exports)Exports"></sup><a class="header-link" href="#id-%5B%5D(%23exports)Exports"></a><p><a class="header-link" href="#id-%5B%5D(%23exports)Exports"></a><a href="#exports"></a>Exports</p></h2><h2 class="cyxy-trs-source cyxy-trs-target">出口</h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">With <code>pub use</code> declarations, items can be <em>re-exported</em> from a different module than the one they were declared in. A re-exported item has multiple paths that refer to the same thing. For example:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">通过使用 pub 使用声明，可以从不同的模块重新导出项，而不是在其中声明的模块。重新导出的项具有多个指向同一事物的路径。例如:</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">lib.rs</p><p class="cyxy-trs-source cyxy-trs-target">莉比</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> answer {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> ANSWER: <span class="hljs-type">i32</span> = <span class="hljs-number">42</span>;
}
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> answer::ANSWER;
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">Now <code>ANSWER</code> can be referred to as either <code>crate::ANSWER</code> or <code>crate​::answer::ANSWER</code>. However, not every path is always <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_26" class="wdautohl_cmVhY2hhYmxl">reachable</wdautohl-customtag>. Take, for example:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">现在，答案可以被称为任何一个板条箱: : 答案或板条箱: : 答案。然而，并不是所有的路径都是可以到达的。举个例子:</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">lib.rs</p><p class="cyxy-trs-source cyxy-trs-target">莉比</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-keyword">mod</span> answer {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> ANSWER: <span class="hljs-type">i32</span> = <span class="hljs-number">42</span>;
}
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> answer::ANSWER;
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code>crate​::answer::ANSWER</code> is public, but it can’t be used from outside the crate, because the <code>answer</code> module is private. Only the re-export <code>crate::ANSWER</code> can be used from outside the crate.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">回答: : ANSWER 是公共的，但不能在箱子外使用，因为回答模块是私有的。只有再出口板条箱: : 才能从箱外使用。</p>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23common-pitfalls)Common%20%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_27%22%20class%3D%22wdautohl_cGl0ZmFsbA__%22%3Epitfalls%3C%2Fwdautohl-customtag%3E"></sup><a class="header-link" href="#id-%5B%5D(%23common-pitfalls)Common%20%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_27%22%20class%3D%22wdautohl_cGl0ZmFsbA__%22%3Epitfalls%3C%2Fwdautohl-customtag%3E"></a><p><a class="header-link" href="#id-%5B%5D(%23common-pitfalls)Common%20%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_27%22%20class%3D%22wdautohl_cGl0ZmFsbA__%22%3Epitfalls%3C%2Fwdautohl-customtag%3E"></a><a href="#common-pitfalls"></a>Common <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_27" class="wdautohl_cGl0ZmFsbA__">pitfalls</wdautohl-customtag></p></h2><h2 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">常见的陷阱</h2>
<dl>

<dt class="hdlist1 cyxy-trs-source cyxy-trs-source-ted">The module tree must be built manually.</dt><dt class="hdlist1 cyxy-trs-source cyxy-trs-target" contenteditable="true">模块树必须手动生成。</dt>

<dd class="cyxy-trs-source cyxy-trs-source-ted">

There’s no <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_28" class="wdautohl_aW1wbGljaXQ_">implicit</wdautohl-customtag> mapping from the _file system tree_ to the _module tree_: We need to declare all modules with the `mod` <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_29" class="wdautohl_a2V5d29yZA__">keyword</wdautohl-customtag>.

</dd><dd class="cyxy-trs-source cyxy-trs-target" contenteditable="true">没有从 _ 文件系统树到 _ 模块树的隐式映射: 我们需要使用‘ mod’关键字声明所有模块。</dd>

<dt class="hdlist1 cyxy-trs-source cyxy-trs-source-ted">Don’t confuse _visibility_ with _reachability_.</dt><dt class="hdlist1 cyxy-trs-source cyxy-trs-target" contenteditable="true">不要混淆可见性和可达性。</dt>

<dd class="cyxy-trs-source cyxy-trs-source-ted">

The visibility of an item is like an _upper bound_, it can’t be increased with re-exports. For example, we can’t re-export a private struct outside of its module.

However, a public item might not be <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_30" class="wdautohl_cmVhY2hhYmxl">reachable</wdautohl-customtag> from outside the crate, if it’s in a private module and isn’t publicly re-exported. To make an item available in the crate root, it’s not enough to make it public; we also need to make it <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_31" class="wdautohl_cmVhY2hhYmxl">reachable</wdautohl-customtag> from the crate root.

</dd><dd class="cyxy-trs-source cyxy-trs-target" contenteditable="true">一个项目的可见性就像一个 _ 上界 _，它不能随着再出口而增加。例如，我们不能在模块之外重新导出私有结构。但是，如果公共项目位于私有模块中并且不公开重新导出，则可能无法从板条箱外部访问该公共项目。要使项在板条箱根目录中可用，仅将其公开是不够的; 我们还需要使它从板条箱根目录可访问。</dd>

<dt class="hdlist1 cyxy-trs-source cyxy-trs-source-ted">Don’t confuse _visibility_ with _availability_.</dt><dt class="hdlist1 cyxy-trs-source cyxy-trs-target" contenteditable="true">不要混淆可见性和可用性。</dt>

<dd class="cyxy-trs-source cyxy-trs-source-ted">

Visibility means that we are <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_32" class="wdautohl_cHJpbmNpcGFsbHk_">principally</wdautohl-customtag> allowed to use an item somewhere. It doesn’t mean that the item is available, i.e. _in scope_, so we might still have to import it (or refer to it with its path).

</dd><dd class="cyxy-trs-source cyxy-trs-target" contenteditable="true">可见性意味着我们主要被允许在某处使用一个项目。这并不意味着该项是可用的，例如 _ in scope _，所以我们可能仍然需要导入它(或者用它的路径引用它)。</dd>

</dl>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23special-cases)Special%20cases"></sup><a class="header-link" href="#id-%5B%5D(%23special-cases)Special%20cases"></a><p><a class="header-link" href="#id-%5B%5D(%23special-cases)Special%20cases"></a><a href="#special-cases"></a>Special cases</p></h2><h2 class="cyxy-trs-source cyxy-trs-target">特殊情况</h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">There are a few language constructs that don’t adhere to the same rules as everything else:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">有一些语言结构并不遵循与其他任何事物相同的规则:</p>
<h3 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23enum-variants-and-fields)Enum%20variants%20and%20fields"></sup><a class="header-link" href="#id-%5B%5D(%23enum-variants-and-fields)Enum%20variants%20and%20fields"></a><p><a class="header-link" href="#id-%5B%5D(%23enum-variants-and-fields)Enum%20variants%20and%20fields"></a><a href="#enum-variants-and-fields"></a>Enum variants and fields</p></h3><h3 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">变体和字段</h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Enum variants and variant fields are always public, and it’s not possible to make them private. Therefore we should be careful when exposing enums publicly, because changing the variants or fields later is not backwards compatible.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">枚举变体和变体字段总是公开的，不可能将它们设置为私有。因此，在公开 enum 时应该小心，因为稍后更改变量或字段是不向后兼容的。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can add the [<code>&lt;a target="_blank" href="https://doc.rust-lang.org/nightly/reference/attributes/type_system.html#the-non_exhaustive-attribute"&gt;non_exhaustive]</code> attribute to an enum to allow adding more variants later. This mean that the enum can’t be matched <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_33" class="wdautohl_ZXhoYXVzdGl2ZWx5">exhaustively</wdautohl-customtag>; we’ll always need to add a wildcard match arm (<code>_ =&gt; {}</code>).</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">你可以在 enum 中添加[[ &lt; a target = " _ blank" href = " https://doc.rust-lang. org/nightly/reference/attributes/type _ system. html # the-non _ 穷举-attribute" &gt; non _ 穷举]属性，以便以后可以添加更多的变体。这意味着枚举无法完全匹配; 我们总是需要添加一个通配符匹配臂(_ = &gt; {})。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Sometimes it’s a good idea to wrap an enum in a struct to hide the implementation details:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">有时在结构中包装枚举以隐藏实现细节是个好主意:</p>
<pre><small></small><div></div><code class="hljs language-csharp"><span class="hljs-function">pub <span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">FooImpl</span>)</span>; <span class="hljs-comment">// FooImpl is private</span>

<span class="hljs-built_in">enum</span> FooImpl {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">Also, when an enum variant has multiple fields, it’s usually better to put them in a separate struct, so it’s possible to make the fields private or make the struct <code>non_exhaustive</code>:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">另外，当 enum 变量有多个字段时，通常最好将它们放在一个单独的结构中，因此可以将字段设置为 private 或者使该结构非详尽无遗:</p>
<pre><small></small><div></div><code class="hljs language-rust"><span class="hljs-comment">// Instead of this:</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Foo</span> {
    Variant {
        field: <span class="hljs-type">i32</span>,
        other_field: <span class="hljs-type">bool</span>,
    }
}

<span class="hljs-comment">// do this:</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-title function_ invoke__">Variant</span>(FooVariant),
}
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FooVariant</span> {
    field: <span class="hljs-type">i32</span>,
    other_field: <span class="hljs-type">bool</span>,
}
</code></pre>
<h3 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23macros)Macros"></sup><a class="header-link" href="#id-%5B%5D(%23macros)Macros"></a><p><a class="header-link" href="#id-%5B%5D(%23macros)Macros"></a><a href="#macros"></a>Macros</p></h3><h3 class="cyxy-trs-source cyxy-trs-target">宏</h3>
<p class="cyxy-trs-source cyxy-trs-source-ted"><wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_34" class="wdautohl_ZGVjbGFyYXRpdmU_">Declarative</wdautohl-customtag> macros (the ones that are declared with <code>macro_rules!</code>) behave more like local variables within a function than like items in some regards. For example, they can be shadowed, they have to be declared before they can be used, and they don’t need to be explicitly imported in child modules <sup class="footnote">[<a href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">声明性宏(用宏 _ 规则声明的宏!)在某些方面，它们更像是函数中的局部变量，而不是类似的项。例如，它们可以被隐藏，在使用它们之前必须声明它们，并且它们不需要在子模块[2]中显式导入。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">And, they can’t be declared public. The <code>#[macro_export]</code> attribute can be added to a macro, which exports it publicly at the crate root. This can be <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_35" class="wdautohl_dW5kZXNpcmFibGU_">undesirable</wdautohl-customtag>, however, if it’s not supposed to be part of the public API; there is no equivalent of <code>pub(crate)</code> for macros.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">而且，它们不能被公开。可以将 # [ macro _ export ]属性添加到宏中，该宏在板条箱根目录中公开导出它。但是，如果它不应该是公共 API 的一部分，那么这可能是不可取的; 宏没有类似于 pub (crate)的东西。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">One workaround for this is to put our macros in a module and <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_36" class="wdautohl_YW5ub3RhdGU_">annotate</wdautohl-customtag> the module with <code>#[macro_use]</code>. The module should be the <em>first module declaration</em> in the crate root. This ensures that the macros can be used everywhere in our crate, but not outside of the crate. Not the most elegant solution, but it works.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">解决这个问题的一个方法是将我们的宏放在一个模块中，并用 # [ macro _ use ]注释该模块。模块应该是板条箱根中的第一个模块声明。这确保了宏可以在我们的板条箱中的任何地方使用，但不能在板条箱外使用。虽然不是最优雅的解决方案，但它确实有效。</p>
<h2 class="cyxy-trs-source cyxy-trs-source-ted"><sup class="fake-head" id="id-%5B%5D(%23why-are-modules-declared-explicitly)Why%20are%20modules%20declared%20explicitly%3F"></sup><a class="header-link" href="#id-%5B%5D(%23why-are-modules-declared-explicitly)Why%20are%20modules%20declared%20explicitly%3F"></a><p><a class="header-link" href="#id-%5B%5D(%23why-are-modules-declared-explicitly)Why%20are%20modules%20declared%20explicitly%3F"></a><a href="#why-are-modules-declared-explicitly"></a>Why are modules declared explicitly?</p></h2><h2 class="cyxy-trs-source cyxy-trs-target" contenteditable="true">为什么要显式声明模块？</h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">I promised to explain why modules have to be declared explicitly. There are a few reasons:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">我承诺要解释为什么必须明确声明模块，原因有以下几点:</p>
<ol>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">With the [<code>&lt;a target="_blank" href="https://doc.rust-lang.org/reference/items/modules.html#the-path-attribute"&gt;path]</code> attribute, a module can be located in a different directory, or have a different name than the file.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">使用[ &lt; a target = " _ blank" href = " https://doc.rust-lang. org/reference/items/modules. html # the-path-attribute" &gt; path ]属性，一个模块可以位于不同的目录中，或者拥有与文件不同的名称。</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Module declarations can have a visibility, e.g. <code>pub(crate) mod foo;</code></p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">模块声明可以具有可见性，例如 pub (crate) mod foo;</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Sometimes there are files which you don’t want to include in the module tree.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">有时，您不希望在模块树中包含某些文件。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">For example, a crate with both a library and a binary target usually contains a <code>lib.rs</code> file for the library and a <code>main.rs</code> file for the binary. Submodules are stored in the same directory, but some modules are only needed by the library, and some only by the binary. By specifying the modules explicitly, you can include only the necessary modules in each file.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">例如，同时具有库和二进制目标的板条箱通常包含库的 lib.rs 文件和二进制文件的 main.rs 文件。子模块存储在同一个目录中，但是有些模块仅仅是库所需要的，有些仅仅是二进制文件所需要的。通过显式地指定模块，您可以在每个文件中只包含必要的模块。</p></li>
</ol>
<p class="cyxy-trs-source cyxy-trs-source-ted">Until next time!</p><p class="cyxy-trs-source cyxy-trs-target">下次见！</p>