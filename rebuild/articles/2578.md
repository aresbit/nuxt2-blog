# Rust基础之变量

在Rust中要知道的第一件事是，所有的变量在默认情况下都是常量。例子 :
```rust

let i = 0;

i = 2; // 错误!
//要声明一个可变的变量，你必须使用mut关键字。

let mut i = 0;

i = 2; // Ok !
//现在让我们来看看类型在Rust中是如何工作的。在这里，没有什么新东西，我们仍然有整数、浮点数、字符串等等。唯一的区别将来自于他们的语法。例如，要声明一个32位的整数，你可以这样做。

let i：i32 = 0;
// 或 :
let i = 0i32;
//你还应该知道，Rust编译器使用类型推理。基本上，你不需要声明变量的类型，它通常可以自己推断出来。例子 :

let i = 0; // 所以它显然是一个整数。
let max=10i32。

if i < max { // max是一个i32，所以编译器推断出i也是一个i32。
    println! ("i is less than max!");
}
//因此，为了总结，这里有一个可用的不同基本类型（也称为 "基元"）的小列表。

i8：一个8位有符号的整数

i16

i32

i64

i128

u8：一个8位无符号整数

u16

u32

u64

u128

f32：一个32位的浮点数

f64：一个64位的浮点数

## 字符串

切片（我们将在本章后面再讨论这个问题）

注意，isize和usize类型也存在，相当于C/C++中的intptr_t和uintptr_t。基本上，在32位系统上，它们将分别为32位，而在64位系统上，它们将为64位。

最后要提到的一点是：在C/C++/Java/等中这种代码是很常见的。:

i++;
++i;
这种语法在Rust中是无效的，你需要

i += 1;
另一个细节可能很重要：如果我们用'_'作为变量名称的开头，如果不使用它，我们就不会得到编译器的警告。这在某些情况下是有用的，尽管它是相当有限的。例子 :

let _i = 0。
是时候回到切片上了。
简单地说，一个片断就是一个数组的一个片段。对于那些做过C/C++的人来说，它只是一个指针和一个尺寸。例子。

let tab = &[0, 1, 2]; // tab是一个包含0、1和2的片断。

println! ("{:?}", tab); //它将显示"[0, 1, 2]"
let s = &tab[1..]; // s现在是一个切片，从tab的第二个元素开始。
println! ("{:?}", s); // 它将显示"[1, 2]"
//就像可以从数组中获得一个切片一样，也可以从Vecs中获得一个切片。

let mut v: Vec<u8> = Vec::new();

v.push(0);
v.push(1);
v.push(2);
let s = &v;
println! ("{:?}", s); // 它将显示"[0, 1, 2]"
let s = &v[1...];
println! ("{:?}", s); // 它将显示"[1, 2]"
//包含数组的类型总是有一个相关的片断。例如，String有&str，OsString有OsStr，等等。
```