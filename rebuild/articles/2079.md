

# Programming Language Evolution

<figure class="fs fu jg jh ji jj fo fp paragraph-image">![](https://miro.medium.com/max/1400/1*PsQdxpXjfSAAUN-Y0lW1ow.jpeg)

## From GOTOs to the structured code

In early languages, you had to write a lot of repetitive code just to do a simple loop. The loop was such a common programming _pattern_, that it was adopted even by the primitive higher-level languages in the era <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_6" class="wdautohl_cHJlZGF0ZQ__">predating</wdautohl-customtag> structured programming. So, there was a time when you still had GOTOs in your programming language but a significant fraction of the code had structured loops:

<pre class="lt lu lv lw ga lx eg ly">10 **LET** N=10  
20 **FOR** I=1 **TO** N  
30 **PRINT** "Hello, World!"  
40 **NEXT** I</pre>

As we know, the subsequent generation of languages not only added structured `IF` statements but also made the structure explicit in the source and ended up <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_7" class="wdautohl_YWJvbGlzaA__">abolishing</wdautohl-customtag> GOTOs completely. This kind of evolution can be seen in other areas, too.

## Objects and pointers

Let’s take a brief look at OOP. The object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_8" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> style of programming does not need an object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_9" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> language. Even nowadays you can find software written in C where methods are just a _convention_ of writing functions whose first <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_10" class="wdautohl_cGFyYW1ldGVy">parameter</wdautohl-customtag> is a pointer to the receiver:

<pre class="lt lu lv lw ga lx eg ly">**void** Point_move(Point* self, **int** dx, **int** dy) { ... }</pre>

Virtual methods are routinely implemented in pure C, too, explicitly keeping a virtual methods table with references to methods somewhere in the object’s structure.

However, the rising popularity of object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_11" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> programming back in the day cemented the growth of languages that incorporated these patterns natively with classes and methods as we know them today.

As hardware became faster, working with objects by reference became so popular in large-scale software systems that even an effort of having to explicitly use `Point*` or some other <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_12" class="wdautohl_c3ludGFjdGlj">syntactic</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_13" class="wdautohl_bm90YXRpb24_">notation</wdautohl-customtag> to <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_14" class="wdautohl_ZGVzaWduYXRl">designate</wdautohl-customtag> references to an object came to be perceived as a _boilerplate_ — a <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_15" class="wdautohl_c3ludGFjdGlj">syntactic</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_16" class="wdautohl_aW5jYW50YXRpb24_">incantation</wdautohl-customtag> that you have to always write when working with business objects. So it was <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_17" class="wdautohl_YWJvbGlzaA__">abolished</wdautohl-customtag>, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_18" class="wdautohl_cGF2aW5n">paving</wdautohl-customtag> the road to the modern approach of having an <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_19" class="wdautohl_aW1wbGljaXQ_">implicit</wdautohl-customtag> reference to all object instances that top application-programming languages (Python, JS, Java) use.

This is also a good example of how a language feature that is <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_20" class="wdautohl_dWJpcXVpdG91cw__">ubiquitous</wdautohl-customtag> today might have a very long history but was not universally adopted by main-stream languages until the right time.

## The scale of software and extensions

The first generations of object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_21" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> languages were created in the 20th century, well before the massive software projects (in terms of lines of code and 3rd-party libraries used) that we see today. These languages were quickly adopted at a scale hardly <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_22" class="wdautohl_ZW52aXNpb24_">envisioned</wdautohl-customtag> by their creators.

The original idea that you can simply declare all the methods you’ll ever need on a class together with its declaration quickly <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_23" class="wdautohl_Y3J1bWJsZQ__">crumbled</wdautohl-customtag>, leading to hundreds `StringUtil` , `FileUtil`, and other “utility classes” in a typical project, which were merely collections of “extension methods”. They were essentially written in an old-school pre-OOP style with a convention of having a receiver of the call as the first <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_24" class="wdautohl_cGFyYW1ldGVy">parameter</wdautohl-customtag> as we saw with the example in C. History goes in circles! So it is not a surprise that a generation of languages designed in the 21st century for large-scale development typically incorporates this pattern via some form of a 1st-class extension concept.

## Patterns, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_25" class="wdautohl_Ym9pbGVycGxhdGU_">Boilerplate</wdautohl-customtag>, Features

I could go on with more examples, like the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_26" class="wdautohl_dGVudW91cw__">tenuous</wdautohl-customtag> `malloc`/`free` dance that was replaced by various <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_27" class="wdautohl_YXV0b21hdGU_">automated</wdautohl-customtag> memory-management schemes, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_28" class="wdautohl_dW53aWVsZHk_">unwieldy</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_29" class="wdautohl_Y2FsbGJhY2s_">callback</wdautohl-customtag>-based programming that gave rise to language support for coroutines, repeated <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_30" class="wdautohl_Ym9pbGVycGxhdGU_">boilerplate</wdautohl-customtag> of collection-manipulating operations leading to support for standard higher-order functions like `filter`, `map`, etc.

I hope that you already see a common <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_31" class="wdautohl_bW90aWY_">motif</wdautohl-customtag> here. As programming evolves, various <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_32" class="wdautohl_dWJpcXVpdG91cw__">ubiquitous</wdautohl-customtag> patterns of code <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_33" class="wdautohl_ZW1lcmdl">emerge</wdautohl-customtag>. These patterns are boring, error-prone, and are totally not fun to work with. Eventually, they get recognized by programming language designers and are incorporated into languages as new features, increasing the overall level of <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_34" class="wdautohl_YWJzdHJhY3Rpb24_">abstraction</wdautohl-customtag>, improving developer productivity and job satisfaction. This story repeats with each generation of languages as newer patterns build on top of features that used to be just programming patterns themselves a generation ago.

## Being modern, staying modern

What does it mean for a programming language to be modern and to stay modern? It means to accept the change, this inevitable cycle of evolution, and to evolve with it. <mark class="uf ug ns">When software developers consistently write or have to automatically generate some repeated pattern of code it sends a strong signal that something is not right, that some language feature is missing.</mark>

<wdautohl-customtag style="font-weight:bold;color:blue;font-size:inherit;display:inline;" id="wdautohl_id_35" class="wdautohl_dGFrZSBhIGxvb2s_">Take a look</wdautohl-customtag> at one more example. As OOP design style scaled, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_36" class="wdautohl_ZGVjb3VwbGU_">decoupling</wdautohl-customtag> the internal storage of data from its <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_37" class="wdautohl_ZXh0ZXJuYWxseQ__">externally</wdautohl-customtag>-visible representation became the norm, thus giving rise to a convention of `getXxx` (getter) and `setXxx` (<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_38" class="wdautohl_c2V0dGVy">setter</wdautohl-customtag>) methods to achieve this <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_39" class="wdautohl_ZW5jYXBzdWxhdGlvbg__">encapsulation</wdautohl-customtag>. It has been going on for 20+ years all over the enterprise codebases with an extensive set of tools helping to generate this <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_40" class="wdautohl_Ym9pbGVycGxhdGU_">boilerplate</wdautohl-customtag>. So nowadays, simply looking at whether a language has or lacks built-in support for this property pattern, we can see if a language is keeping up with the needs of modern large-scale software development.

## Removing obsolete features

Let’s get back to the example we’ve started with — a transition from programming with GOTOs to modern structured programming. The real <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_41" class="wdautohl_YnJlYWt0aHJvdWdo">breakthrough</wdautohl-customtag> came not just from adding structured loops and <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_42" class="wdautohl_Y29uZGl0aW9uYWxz">conditionals</wdautohl-customtag> to languages, but from the complete removal of the GOTO statement.

A <wdautohl-customtag style="font-weight:bold;color:blue;font-size:inherit;display:inline;" id="wdautohl_id_43" class="wdautohl_Y2FzZSBpbiBwb2ludA__">case in point</wdautohl-customtag> is a notorious “billion-dollar problem” with null pointers. Adding language support for better null-handling is only half a solution that helps developers with writing the null-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_44" class="wdautohl_YXZvaWRhbmNl">avoidance</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_45" class="wdautohl_Ym9pbGVycGxhdGU_">boilerplate</wdautohl-customtag>. The real <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_46" class="wdautohl_YnJlYWt0aHJvdWdo">breakthrough</wdautohl-customtag> is to completely forbid storing nulls into arbitrary reference types.

This removal of obsolete features is often the hardest <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_47" class="wdautohl_aHVyZGxl">hurdle</wdautohl-customtag> that prevents languages from adapting to the ever-changing world, leading to their ultimate downfall under the weight of features they add. Of course, it also depends on the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_48" class="wdautohl_aW5lcnRpYQ__">inertia</wdautohl-customtag> of the language, the size of its ecosystem. The more widespread the language is, the more deadweight it can afford to support without <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_49" class="wdautohl_Y3J1bWJsZQ__">crumbling</wdautohl-customtag>. But ultimately, the general law of evolution, as stated by Charles Darwin, holds for programming languages, too:

> It is not the most intellectual of the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_50" class="wdautohl_c3BlY2ll">species</wdautohl-customtag> that survives; it is not the strongest that survives; but the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_51" class="wdautohl_c3BlY2ll">species</wdautohl-customtag> that survives is the one that is able best to adapt and adjust to the changing environment in which it finds itself.

## Further reading

If you are interested in trends that shape the design of modern programming languages, then check out my other related stories:

*   [Dealing with absence of value](/dealing-with-absence-of-value-307b80534903)
*   [Types are moving to the right](/types-are-moving-to-the-right-22c0ef31dd4a)
*   [Functional Programming is on the rise](/functional-programing-is-on-the-rise-ebd5c705eaef)
*   [Application programming language](/application-programming-language-ff7f0063c16)
*   [The End of the Semicolon Era](/the-end-of-the-semicolon-era-60ab95e669ab)
*   [Immutability we can afford](/immutability-we-can-afford-10c0dcb8351d)

[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Fp%2Fab7d7d2b0d0b&operation=register&redirect=https%3A%2F%2Felizarov.medium.com%2Fprogramming-language-evolution-ab7d7d2b0d0b&user=Roman+Elizarov&userId=4762e889f8fc&source=-----ab7d7d2b0d0b---------------------clap_footer--------------)
