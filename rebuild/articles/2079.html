<h1><sup class="fake-head" id="id-Programming%20Language%20Evolution"></sup><a class="header-link" href="#id-Programming%20Language%20Evolution"><p class="cyxy-trs-source cyxy-trs-source-ted">Programming Language Evolution</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">程序设计语言的演变</p></a></h1>
<p class="cyxy-trs-source"></p><figure class="fs fu jg jh ji jj fo fp paragraph-image"><span class="image-container"><img data-viewer="" alt="" title="" src="https://miro.medium.com/max/1400/1*PsQdxpXjfSAAUN-Y0lW1ow.jpeg"><small class="desc"></small></span><p class="cyxy-trs-source"></p>
<h2><sup class="fake-head" id="id-From%20GOTOs%20to%20the%20structured%20code"></sup><a class="header-link" href="#id-From%20GOTOs%20to%20the%20structured%20code"><p class="cyxy-trs-source cyxy-trs-source-ted">From GOTOs to the structured code</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">从 GOTOs 到结构化代码</p></a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">In early languages, you had to write a lot of repetitive code just to do a simple loop. The loop was such a common programming <em>pattern</em>, that it was adopted even by the primitive higher-level languages in the era <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_6" class="wdautohl_cHJlZGF0ZQ__">predating</wdautohl-customtag> structured programming. So, there was a time when you still had GOTOs in your programming language but a significant fraction of the code had structured loops:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">在早期的语言中，您必须编写大量重复的代码才能完成一个简单的循环。循环是一种非常常见的编程模式，甚至在早于结构化编程时代的原始高级语言中也采用了这种模式。因此，曾经有一段时间，你的编程语言中仍然有 GOTOs，但是很大一部分代码是结构化的循环:</p>
<pre class="lt lu lv lw ga lx eg ly">10 **LET** N=10  
20 **FOR** I=1 **TO** N  
30 **PRINT** "Hello, World!"  
40 **NEXT** I</pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">As we know, the subsequent generation of languages not only added structured <code>IF</code> statements but also made the structure explicit in the source and ended up <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_7" class="wdautohl_YWJvbGlzaA__">abolishing</wdautohl-customtag> GOTOs completely. This kind of evolution can be seen in other areas, too.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">正如我们所知，随后的语言生成不仅增加了结构化 IF 语句，而且在源代码中明确了结构，最终完全废除了 GOTOs。这种进化也可以在其他领域看到。</p>
<h2><sup class="fake-head" id="id-Objects%20and%20pointers"></sup><a class="header-link" href="#id-Objects%20and%20pointers"><p class="cyxy-trs-source cyxy-trs-source-ted">Objects and pointers</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">对象和指针</p></a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">Let’s take a brief look at OOP. The object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_8" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> style of programming does not need an object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_9" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> language. Even nowadays you can find software written in C where methods are just a <em>convention</em> of writing functions whose first <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_10" class="wdautohl_cGFyYW1ldGVy">parameter</wdautohl-customtag> is a pointer to the receiver:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">让我们简单地看一下 OOP。面向对象的编程风格不需要面向对象的语言。即使是现在，你也可以找到用 c 语言编写的软件，其中的方法只是编写函数的惯例，而函数的第一个参数是指向接收方的指针:</p>
<pre class="lt lu lv lw ga lx eg ly">**void** Point_move(Point* self, **int** dx, **int** dy) { ... }</pre>
<p class="cyxy-trs-source cyxy-trs-source-ted">Virtual methods are routinely implemented in pure C, too, explicitly keeping a virtual methods table with references to methods somewhere in the object’s structure.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">虚方法通常也是用纯 c 实现的，显式地保留一个虚方法表，其中包含对对象结构中某处方法的引用。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">However, the rising popularity of object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_11" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> programming back in the day cemented the growth of languages that incorporated these patterns natively with classes and methods as we know them today.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">然而，随着面向对象程序设计的日益流行，我们今天所熟知的类和方法本身就包含了这些模式的语言得到了发展。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">As hardware became faster, working with objects by reference became so popular in large-scale software systems that even an effort of having to explicitly use <code>Point*</code> or some other <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_12" class="wdautohl_c3ludGFjdGlj">syntactic</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_13" class="wdautohl_bm90YXRpb24_">notation</wdautohl-customtag> to <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_14" class="wdautohl_ZGVzaWduYXRl">designate</wdautohl-customtag> references to an object came to be perceived as a <em>boilerplate</em> — a <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_15" class="wdautohl_c3ludGFjdGlj">syntactic</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_16" class="wdautohl_aW5jYW50YXRpb24_">incantation</wdautohl-customtag> that you have to always write when working with business objects. So it was <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_17" class="wdautohl_YWJvbGlzaA__">abolished</wdautohl-customtag>, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_18" class="wdautohl_cGF2aW5n">paving</wdautohl-customtag> the road to the modern approach of having an <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_19" class="wdautohl_aW1wbGljaXQ_">implicit</wdautohl-customtag> reference to all object instances that top application-programming languages (Python, JS, Java) use.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">随着硬件变得越来越快，通过引用处理对象在大型软件系统中变得非常流行，即使是必须明确使用 Point * 或其他一些语法标记来指定对象引用的努力，也会被视为样板文件ーー一种在处理业务对象时必须一直编写的语法咒语。所以它被废除了，为现代方法铺平了道路，这种方法是对顶级应用程序编程语言(Python，JS，Java)使用的所有对象实例进行隐式引用。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">This is also a good example of how a language feature that is <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_20" class="wdautohl_dWJpcXVpdG91cw__">ubiquitous</wdautohl-customtag> today might have a very long history but was not universally adopted by main-stream languages until the right time.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">这也是一个很好的例子，说明今天普遍存在的语言特性可能有很长的历史，但是直到适当的时候才被主流语言普遍采用。</p>
<h2><sup class="fake-head" id="id-The%20scale%20of%20software%20and%20extensions"></sup><a class="header-link" href="#id-The%20scale%20of%20software%20and%20extensions"><p class="cyxy-trs-source cyxy-trs-source-ted">The scale of software and extensions</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">软件和扩展的规模</p></a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">The first generations of object-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_21" class="wdautohl_b3JpZW50">oriented</wdautohl-customtag> languages were created in the 20th century, well before the massive software projects (in terms of lines of code and 3rd-party libraries used) that we see today. These languages were quickly adopted at a scale hardly <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_22" class="wdautohl_ZW52aXNpb24_">envisioned</wdautohl-customtag> by their creators.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">第一代面向对象语言是在20世纪创建的，远早于我们今天看到的大规模软件项目(使用的代码行和第三方库)。这些语言很快被采用，其规模是它们的创造者难以想象的。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The original idea that you can simply declare all the methods you’ll ever need on a class together with its declaration quickly <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_23" class="wdautohl_Y3J1bWJsZQ__">crumbled</wdautohl-customtag>, leading to hundreds <code>StringUtil</code> , <code>FileUtil</code>, and other “utility classes” in a typical project, which were merely collections of “extension methods”. They were essentially written in an old-school pre-OOP style with a convention of having a receiver of the call as the first <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_24" class="wdautohl_cGFyYW1ldGVy">parameter</wdautohl-customtag> as we saw with the example in C. History goes in circles! So it is not a surprise that a generation of languages designed in the 21st century for large-scale development typically incorporates this pattern via some form of a 1st-class extension concept.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">最初的想法是，你可以简单地声明一个类中所有你需要的方法以及它的声明，但这个想法很快就崩溃了，导致在一个典型的项目中出现了数百个 stringutill、 filetil 和其他“实用程序类”，这些类仅仅是“扩展方法”的集合。它们基本上是以老式的学前 oop 风格编写的，其约定是将调用的接收者作为第一个参数，正如我们在 c 中的例子中看到的那样，历史在绕圈子！因此，在21世纪为大规模开发而设计的一代语言通常会通过某种形式的一级扩展概念来包含这种模式，也就不足为奇了。</p>
<h2><sup class="fake-head" id="id-Patterns%2C%20%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_25%22%20class%3D%22wdautohl_Ym9pbGVycGxhdGU_%22%3EBoilerplate%3C%2Fwdautohl-customtag%3E%2C%20Features"></sup><a class="header-link" href="#id-Patterns%2C%20%3Cwdautohl-customtag%20style%3D%22font-weight%3Abold%3Bcolor%3Ared%3Bfont-size%3Ainherit%3Bdisplay%3Ainline%3B%22%20id%3D%22wdautohl_id_25%22%20class%3D%22wdautohl_Ym9pbGVycGxhdGU_%22%3EBoilerplate%3C%2Fwdautohl-customtag%3E%2C%20Features"><p class="cyxy-trs-source cyxy-trs-source-ted">Patterns, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_25" class="wdautohl_Ym9pbGVycGxhdGU_">Boilerplate</wdautohl-customtag>, Features</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">图案，样板，特征</p></a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">I could go on with more examples, like the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_26" class="wdautohl_dGVudW91cw__">tenuous</wdautohl-customtag> <code>malloc</code>/<code>free</code> dance that was replaced by various <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_27" class="wdautohl_YXV0b21hdGU_">automated</wdautohl-customtag> memory-management schemes, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_28" class="wdautohl_dW53aWVsZHk_">unwieldy</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_29" class="wdautohl_Y2FsbGJhY2s_">callback</wdautohl-customtag>-based programming that gave rise to language support for coroutines, repeated <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_30" class="wdautohl_Ym9pbGVycGxhdGU_">boilerplate</wdautohl-customtag> of collection-manipulating operations leading to support for standard higher-order functions like <code>filter</code>, <code>map</code>, etc.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">我还可以举出更多的例子，比如被各种自动内存管理方案所取代的微弱的 malloc/free dance，为协同程序提供语言支持的笨拙的基于回调的编程，以及为过滤器、 map 等标准高阶函数提供支持的收集操作的重复样板。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">I hope that you already see a common <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_31" class="wdautohl_bW90aWY_">motif</wdautohl-customtag> here. As programming evolves, various <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_32" class="wdautohl_dWJpcXVpdG91cw__">ubiquitous</wdautohl-customtag> patterns of code <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_33" class="wdautohl_ZW1lcmdl">emerge</wdautohl-customtag>. These patterns are boring, error-prone, and are totally not fun to work with. Eventually, they get recognized by programming language designers and are incorporated into languages as new features, increasing the overall level of <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_34" class="wdautohl_YWJzdHJhY3Rpb24_">abstraction</wdautohl-customtag>, improving developer productivity and job satisfaction. This story repeats with each generation of languages as newer patterns build on top of features that used to be just programming patterns themselves a generation ago.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">我希望你们已经在这里看到了一个共同的主题。随着编程的发展，各种无处不在的代码模式应运而生。这些模式很无聊，容易出错，并且完全不适合使用。最终，它们得到了编程语言设计者的认可，并作为新特性纳入到语言中，提高了整体的抽象水平，提高了开发人员的生产力和工作满意度。这个故事在每一代语言中不断重复，因为新的模式建立在上一代人以前只是编程模式的特性之上。</p>
<h2><sup class="fake-head" id="id-Being%20modern%2C%20staying%20modern"></sup><a class="header-link" href="#id-Being%20modern%2C%20staying%20modern"><p class="cyxy-trs-source cyxy-trs-source-ted">Being modern, staying modern</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">现代，保持现代</p></a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">What does it mean for a programming language to be modern and to stay modern? It means to accept the change, this inevitable cycle of evolution, and to evolve with it. <mark class="uf ug ns">When software developers consistently write or have to automatically generate some repeated pattern of code it sends a strong signal that something is not right, that some language feature is missing.</mark></p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">一门编程语言现代化并保持现代化意味着什么？它意味着接受改变，这个不可避免的进化周期，并随之进化。当软件开发人员不断地编写或者不得不自动生成一些重复的代码模式时，它就会发出一个强烈的信号，表明有些地方不对劲，有些语言功能缺失了。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><wdautohl-customtag style="font-weight:bold;color:blue;font-size:inherit;display:inline;" id="wdautohl_id_35" class="wdautohl_dGFrZSBhIGxvb2s_">Take a look</wdautohl-customtag> at one more example. As OOP design style scaled, <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_36" class="wdautohl_ZGVjb3VwbGU_">decoupling</wdautohl-customtag> the internal storage of data from its <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_37" class="wdautohl_ZXh0ZXJuYWxseQ__">externally</wdautohl-customtag>-visible representation became the norm, thus giving rise to a convention of <code>getXxx</code> (getter) and <code>setXxx</code> (<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_38" class="wdautohl_c2V0dGVy">setter</wdautohl-customtag>) methods to achieve this <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_39" class="wdautohl_ZW5jYXBzdWxhdGlvbg__">encapsulation</wdautohl-customtag>. It has been going on for 20+ years all over the enterprise codebases with an extensive set of tools helping to generate this <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_40" class="wdautohl_Ym9pbGVycGxhdGU_">boilerplate</wdautohl-customtag>. So nowadays, simply looking at whether a language has or lacks built-in support for this property pattern, we can see if a language is keeping up with the needs of modern large-scale software development.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">再看一个例子。随着 OOP 设计风格的扩展，将数据的内部存储与其外部可见的表示解耦成为规范，从而产生了实现这种封装的 getXxx (getter)和 setXxx (setter)方法的约定。它已经在整个企业代码库中持续了20多年，有一系列广泛的工具帮助生成这样的样板文件。因此，现在，只要简单地看一下一种语言是否具有对这种属性模式的内置支持，我们就可以看到一种语言是否符合现代大规模软件开发的需要。</p>
<h2><sup class="fake-head" id="id-Removing%20obsolete%20features"></sup><a class="header-link" href="#id-Removing%20obsolete%20features"><p class="cyxy-trs-source cyxy-trs-source-ted">Removing obsolete features</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">移除过时的功能</p></a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">Let’s get back to the example we’ve started with — a transition from programming with GOTOs to modern structured programming. The real <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_41" class="wdautohl_YnJlYWt0aHJvdWdo">breakthrough</wdautohl-customtag> came not just from adding structured loops and <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_42" class="wdautohl_Y29uZGl0aW9uYWxz">conditionals</wdautohl-customtag> to languages, but from the complete removal of the GOTO statement.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">让我们回到我们开始的例子---- 从使用 GOTOs 编程到现代结构化编程的过渡。真正的突破不仅来自于向语言中添加结构化循环和条件句，还来自于对 GOTO 语句的彻底删除。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">A <wdautohl-customtag style="font-weight:bold;color:blue;font-size:inherit;display:inline;" id="wdautohl_id_43" class="wdautohl_Y2FzZSBpbiBwb2ludA__">case in point</wdautohl-customtag> is a notorious “billion-dollar problem” with null pointers. Adding language support for better null-handling is only half a solution that helps developers with writing the null-<wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_44" class="wdautohl_YXZvaWRhbmNl">avoidance</wdautohl-customtag> <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_45" class="wdautohl_Ym9pbGVycGxhdGU_">boilerplate</wdautohl-customtag>. The real <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_46" class="wdautohl_YnJlYWt0aHJvdWdo">breakthrough</wdautohl-customtag> is to completely forbid storing nulls into arbitrary reference types.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">一个典型的例子是一个臭名昭著的带有空指针的“十亿美元问题”。为更好的 null 处理添加语言支持只是帮助开发人员编写避免 null 样板文件的解决方案的一半。真正的突破是完全禁止将 null 值存储到任意引用类型中。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">This removal of obsolete features is often the hardest <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_47" class="wdautohl_aHVyZGxl">hurdle</wdautohl-customtag> that prevents languages from adapting to the ever-changing world, leading to their ultimate downfall under the weight of features they add. Of course, it also depends on the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_48" class="wdautohl_aW5lcnRpYQ__">inertia</wdautohl-customtag> of the language, the size of its ecosystem. The more widespread the language is, the more deadweight it can afford to support without <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_49" class="wdautohl_Y3J1bWJsZQ__">crumbling</wdautohl-customtag>. But ultimately, the general law of evolution, as stated by Charles Darwin, holds for programming languages, too:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">去除过时的特性往往是阻止语言适应不断变化的世界的最大障碍，导致它们在增加的特性的重压下最终崩溃。当然，这也取决于语言的惯性和生态系统的规模。这种语言越是普及，就越有能力在不崩溃的情况下支撑起无谓的负担。但最终，正如查尔斯 · 达尔文所言，进化的一般规律也适用于编程语言:</p>
<blockquote>
  <p class="cyxy-trs-source cyxy-trs-source-ted">It is not the most intellectual of the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_50" class="wdautohl_c3BlY2ll">species</wdautohl-customtag> that survives; it is not the strongest that survives; but the <wdautohl-customtag style="font-weight:bold;color:red;font-size:inherit;display:inline;" id="wdautohl_id_51" class="wdautohl_c3BlY2ll">species</wdautohl-customtag> that survives is the one that is able best to adapt and adjust to the changing environment in which it finds itself.</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">幸存下来的并不是最聪明的物种，也不是最强壮的物种，而是能够最好地适应和适应变化中的环境的物种。</p>
</blockquote>
<h2><sup class="fake-head" id="id-Further%20reading"></sup><a class="header-link" href="#id-Further%20reading"><p class="cyxy-trs-source cyxy-trs-source-ted">Further reading</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">进一步阅读</p></a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you are interested in trends that shape the design of modern programming languages, then check out my other related stories:</p><p class="cyxy-trs-source cyxy-trs-target" contenteditable="true">如果你对塑造现代编程语言设计的趋势感兴趣，那么看看我的其他相关故事:</p>
<ul>
<li><a href="/dealing-with-absence-of-value-307b80534903" class="cyxy-trs-source">Dealing with absence of value<font class="cyxy-trs-target"> 处理价值缺失的问题</font></a></li>
<li><a href="/types-are-moving-to-the-right-22c0ef31dd4a" class="cyxy-trs-source cyxy-trs-source-ted">Types are moving to the right</a><a href="/types-are-moving-to-the-right-22c0ef31dd4a" class="cyxy-trs-source cyxy-trs-target">类型向右移动</a></li>
<li><a href="/functional-programing-is-on-the-rise-ebd5c705eaef" class="cyxy-trs-source cyxy-trs-source-ted">Functional Programming is on the rise</a><a href="/functional-programing-is-on-the-rise-ebd5c705eaef" class="cyxy-trs-source cyxy-trs-target">函数式编程正在兴起</a></li>
<li><a href="/application-programming-language-ff7f0063c16" class="cyxy-trs-source">Application programming language<font class="cyxy-trs-target"> 应用程序设计语言</font></a></li>
<li><a href="/the-end-of-the-semicolon-era-60ab95e669ab" class="cyxy-trs-source cyxy-trs-source-ted">The End of the Semicolon Era</a><a href="/the-end-of-the-semicolon-era-60ab95e669ab" class="cyxy-trs-source cyxy-trs-target">分号时代的终结</a></li>
<li><a href="/immutability-we-can-afford-10c0dcb8351d" class="cyxy-trs-source">Immutability we can afford<font class="cyxy-trs-target"> 我们能够承受的不变性</font></a></li>
</ul>
<p class="cyxy-trs-source"><a href="https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Fp%2Fab7d7d2b0d0b&amp;operation=register&amp;redirect=https%3A%2F%2Felizarov.medium.com%2Fprogramming-language-evolution-ab7d7d2b0d0b&amp;user=Roman+Elizarov&amp;userId=4762e889f8fc&amp;source=-----ab7d7d2b0d0b---------------------clap_footer--------------"></a></p></figure>